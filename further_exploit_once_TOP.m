function [areAllSaturated, unsel, tours, costs] = further_exploit_once_TOP(node, rwd, BGT, unsel, tours, costs)

%% Compute ricr (Reward to Incremental-Cost Ratio)
% Compute Reward to Incremental-Cost Ratio (ricr) with respect to the 1st tour
increCosts_1 = Inf * ones(size(unsel,1), 1); 
connPoints_1 = zeros(length(unsel), 1);
for idx = 1:length(unsel)
    thisNode = node(unsel(idx), :);
    thisIncreCost = Inf;
    for jj = 1:length(tours{1})
        nodeA = tours{1}(jj);
        if jj == length(tours{1})
            nodeB = tours{1}(1);
        else
            nodeB = tours{1}(jj+1);
        end
        tempIncreCost = get_edge_weight(thisNode, node(nodeA, :)) + get_edge_weight(thisNode, node(nodeB, :)) - get_edge_weight(node(nodeA, :), node(nodeB, :));
        if tempIncreCost < thisIncreCost
            thisIncreCost = tempIncreCost;
            connPointA = nodeA;
        end
    end
    increCosts_1(idx, 1) = thisIncreCost;
    connPoints_1(idx, 1) = connPointA;
end
ricr_1 = rwd(unsel) ./ increCosts_1;

% Compute Reward to Incremental-Cost Ratio (ricr) with respect to the 2nd tour
increCosts_2 = Inf * ones(size(unsel,1), 1); 
connPoints_2 = zeros(length(unsel), 1);
for idx = 1:length(unsel)
    thisNode = node(unsel(idx), :);
    thisIncreCost = Inf;
    for jj = 1:length(tours{2})
        nodeA = tours{2}(jj);
        if jj == length(tours{2})
            nodeB = tours{2}(1);
        else
            nodeB = tours{2}(jj+1);
        end
        tempIncreCost = get_edge_weight(thisNode, node(nodeA, :)) + get_edge_weight(thisNode, node(nodeB, :)) - get_edge_weight(node(nodeA, :), node(nodeB, :));
        if tempIncreCost < thisIncreCost
            thisIncreCost = tempIncreCost;
            connPointA = nodeA;
        end
    end
    increCosts_2(idx, 1) = thisIncreCost;
    connPoints_2(idx, 1) = connPointA;
end
ricr_2 = rwd(unsel) ./ increCosts_2;

% Compute Reward to Incremental-Cost Ratio (ricr) with respect to the 3rd tour
increCosts_3 = Inf * ones(size(unsel,1), 1); 
connPoints_3 = zeros(length(unsel), 1);
for idx = 1:length(unsel)
    thisNode = node(unsel(idx), :);
    thisIncreCost = Inf;
    for jj = 1:length(tours{3})
        nodeA = tours{3}(jj);
        if jj == length(tours{3})
            nodeB = tours{3}(1);
        else
            nodeB = tours{3}(jj+1);
        end
        tempIncreCost = get_edge_weight(thisNode, node(nodeA, :)) + get_edge_weight(thisNode, node(nodeB, :)) - get_edge_weight(node(nodeA, :), node(nodeB, :));
        if tempIncreCost < thisIncreCost
            thisIncreCost = tempIncreCost;
            connPointA = nodeA;
        end
    end
    increCosts_3(idx, 1) = thisIncreCost;                     % increCosts_3 is a column vector of the same length as unsel/nodesUnsel
    connPoints_3(idx, 1) = connPointA;                        % connPoints_3 is a column vector of the same length as unsel/nodesUnsel
end
ricr_3 = rwd(unsel) ./ increCosts_3;

% Summary
connPoints = [connPoints_1; connPoints_2; connPoints_3];     % connPoints is a length(unsel)-by-3 matrix
increCosts = [increCosts_1, increCosts_2, increCosts_3];     % increCosts is a length(unsel)-by-3 matrix
ricr       = [ricr_1; ricr_2; ricr_3];                       % ricr is a stacked column vector; its length is 3 * length of unsel/nodesUnsel


%% Insert unsel to tours depending on ricr
areAllSaturated = false;

[~, idx] = sort(ricr, 1, 'descend');
for k = 1:length(idx)
    whichTour   = ceil(idx(k) / length(unsel));
    maxUnsel    = unsel(rem(idx(k) - 1, length(unsel)) + 1);
    pointToConn = connPoints(rem(idx(k) - 1, length(unsel)) + 1, whichTour);
    if (increCosts(rem(idx(k) - 1, length(unsel)) + 1, whichTour)...
            + costs(whichTour) <= BGT)
        % Update tour
        if pointToConn == length(tours{whichTour})
            tours{whichTour} = [tours{whichTour}, maxIdx];
        else
            tours{whichTour} = [tours{whichTour}(1:pos), maxUnsel, tours{whichTour}(pos+1:end)];
        end
        % Update tour cost
        costs{whichTour} = costs{whichTour} + increCosts(rem(idx(k) - 1, length(unsel)) + 1, whichTour);
        % Update unsel
        unsel = setdiff(1:size(node, 1), [tour{1}, tour{2}, tour{3}]);
        return;
    end
    if (k == length(idx))
        areAllSaturated = true;  % If cannot select more node with given budget,
        return;                  % then return.
    end
end



